import mongoose from "mongoose";
import mongoosePaginate from "mongoose-paginate-v2";

const bagPurchaseSchema = new mongoose.Schema(
  {
    purchaseNumber: {
      type: String,
      required: false, // Auto-generated by pre-save middleware
      unique: true,
      trim: true,
    },
    supplier: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Supplier",
      required: true,
    },
    purchaseDate: {
      type: Date,
      required: true,
      default: Date.now,
    },
    bags: {
      type: Map,
      of: {
        quantity: {
          type: Number,
          default: 0,
          min: 0,
        },
        unit: {
          type: String,
          enum: ["tons", "quintals", "50kg bags", "25kg bags", "20kg bags", "15kg bags", "10kg bags", "5kg bags", "100kg sacks", "50kg sacks", "25kg sacks", "bags", "pieces", "rolls", "sheets", "boxes", "packets", "bundles", "units", "sets", "kits", "pairs", "meters", "liters"],
          default: "50kg bags"
        },
        unitPrice: {
          type: Number,
          default: 0,
          min: 0,
        },
        totalPrice: {
          type: Number,
          default: 0,
          min: 0,
        },
      },
      default: new Map()
    },
    totalQuantity: {
      type: Number,
      default: 0,
      min: 0,
    },
    subtotal: {
      type: Number,
      default: 0,
      min: 0,
    },
    tax: {
      type: Number,
      default: 0,
      min: 0,
    },
    discount: {
      type: Number,
      default: 0,
      min: 0,
    },
    totalAmount: {
      type: Number,
      default: 0,
      min: 0,
    },
    paymentMethod: {
      type: String,
      enum: ["Cash", "Bank Transfer", "Check", "Credit"],
      default: "Cash",
    },
    paymentStatus: {
      type: String,
      enum: ["Pending", "Partial", "Paid"],
      default: "Pending",
    },
    paidAmount: {
      type: Number,
      default: 0,
      min: 0,
    },
    dueAmount: {
      type: Number,
      default: 0,
      min: 0,
    },
    dueDate: {
      type: Date,
    },
    status: {
      type: String,
      enum: ["Pending", "Received", "Cancelled", "Completed"],
      default: "Pending",
    },
    receivedDate: {
      type: Date,
    },
    notes: {
      type: String,
      trim: true,
    },
    warehouse: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Warehouse",
      required: true,
    },
    createdBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    updatedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
  },
  {
    timestamps: true,
  }
);

// Add pagination plugin
bagPurchaseSchema.plugin(mongoosePaginate);

// Index for better query performance
bagPurchaseSchema.index({ purchaseNumber: 1, warehouse: 1 });
bagPurchaseSchema.index({ supplier: 1, warehouse: 1 });
bagPurchaseSchema.index({ purchaseDate: 1, warehouse: 1 });
bagPurchaseSchema.index({ status: 1, warehouse: 1 });

// Pre-save middleware to auto-generate purchase number
bagPurchaseSchema.pre("save", async function(next) {
  if (this.isNew && !this.purchaseNumber) {
    try {
      const count = await this.constructor.countDocuments();
      const year = new Date().getFullYear();
      const month = String(new Date().getMonth() + 1).padStart(2, '0');
      const day = String(new Date().getDate()).padStart(2, '0');
      this.purchaseNumber = `BP-${year}${month}${day}-${String(count + 1).padStart(4, '0')}`;
      console.log('Generated bag purchase number:', this.purchaseNumber);
    } catch (error) {
      console.error('Error generating bag purchase number:', error);
      // Fallback to timestamp-based number
      this.purchaseNumber = `BP-${Date.now()}`;
    }
  }
  next();
});

// Pre-save middleware to calculate totals
bagPurchaseSchema.pre("save", function (next) {
  // Calculate bag totals - works with Map structure
  let totalQty = 0;
  let subtotal = 0;

  if (this.bags && this.bags instanceof Map) {
    this.bags.forEach((bagData, productType) => {
      if (bagData && bagData.quantity > 0) {
        bagData.totalPrice = bagData.quantity * bagData.unitPrice;
        totalQty += bagData.quantity;
        subtotal += bagData.totalPrice;
      }
    });
  } else if (this.bags && typeof this.bags === 'object') {
    // Fallback for object structure (converts to Map)
    Object.keys(this.bags).forEach((productType) => {
      const bagData = this.bags[productType];
      if (bagData && bagData.quantity > 0) {
        bagData.totalPrice = bagData.quantity * bagData.unitPrice;
        totalQty += bagData.quantity;
        subtotal += bagData.totalPrice;
      }
    });
  }

  this.totalQuantity = totalQty;
  this.subtotal = subtotal;
  this.totalAmount = this.subtotal + this.tax - this.discount;
  this.dueAmount = this.totalAmount - this.paidAmount;

  next();
});

// Method to mark as received
bagPurchaseSchema.methods.markAsReceived = function () {
  this.status = "Received";
  this.receivedDate = new Date();
  return this.save();
};

// Method to update payment
bagPurchaseSchema.methods.updatePayment = function (amount) {
  this.paidAmount += amount;
  this.dueAmount = Math.max(0, this.totalAmount - this.paidAmount);
  
  if (this.dueAmount === 0) {
    this.paymentStatus = "Paid";
  } else if (this.paidAmount > 0) {
    this.paymentStatus = "Partial";
  }
  
  return this.save();
};

// Virtual for total bags
bagPurchaseSchema.virtual("totalBags").get(function () {
  if (this.bags instanceof Map) {
    let total = 0;
    this.bags.forEach((bagData) => {
      total += bagData.quantity || 0;
    });
    return total;
  } else if (this.bags && typeof this.bags === 'object') {
    return Object.values(this.bags).reduce((total, bag) => total + (bag.quantity || 0), 0);
  }
  return 0;
});

const BagPurchase = mongoose.model("BagPurchase", bagPurchaseSchema);

export default BagPurchase;

